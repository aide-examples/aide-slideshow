<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation - AIDE Slideshow</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        /* Documentation Layout */
        .docs-layout {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            min-height: calc(100vh - 60px);
        }

        /* Sidebar */
        .docs-sidebar {
            width: 250px;
            flex-shrink: 0;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            position: sticky;
            top: 60px;
            height: calc(100vh - 60px);
            overflow-y: auto;
        }
        .docs-sidebar h3 {
            color: #2563eb;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 20px 0 10px 0;
        }
        .docs-sidebar h3:first-child { margin-top: 0; }
        .docs-sidebar ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .docs-sidebar li { margin: 2px 0; }
        .docs-sidebar a {
            display: block;
            padding: 6px 10px;
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .docs-sidebar a:hover {
            color: #333;
            background: #f3f4f6;
        }
        .docs-sidebar a.active {
            color: #2563eb;
            background: rgba(37, 99, 235, 0.1);
        }
        .docs-sidebar .indent { padding-left: 20px; }

        /* Main Content */
        .docs-content {
            flex: 1;
            padding: 30px;
            min-width: 0;
        }

        /* Breadcrumb */
        .breadcrumb {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 20px;
        }
        .breadcrumb a { color: #2563eb; }
        .breadcrumb span { margin: 0 8px; }

        /* Mobile sidebar toggle */
        .sidebar-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #2563eb;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        @media (max-width: 768px) {
            .docs-sidebar {
                position: fixed;
                left: -260px;
                top: 60px;
                height: calc(100vh - 60px);
                z-index: 150;
                transition: left 0.3s;
                box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            }
            .docs-sidebar.open { left: 0; }
            .sidebar-toggle { display: block; }
            .docs-content { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="header sticky">
        <h1>AIDE - Documentation</h1>
        <a href="/" class="header-btn">Back to Control</a>
    </div>

    <div class="docs-layout">
        <nav class="docs-sidebar" id="sidebar">
            <!-- Navbar wird dynamisch geladen -->
            <p style="color: #666; font-size: 0.9rem;">Loading navigation...</p>
        </nav>

        <main class="docs-content">
            <div id="breadcrumb" class="breadcrumb"></div>
            <div id="readme" class="content-loading">Loading documentation...</div>
        </main>
    </div>

    <button class="sidebar-toggle" onclick="document.getElementById('sidebar').classList.toggle('open')">
        ☰
    </button>

    <script src="/static/js/marked.min.js"></script>
    <script src="/static/js/mermaid.min.js"></script>
    <script>
        // Initialize mermaid
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: { useMaxWidth: true, htmlLabels: true }
        });

        // Custom renderer for mermaid code blocks
        const renderer = new marked.Renderer();
        const originalCodeRenderer = renderer.code.bind(renderer);

        renderer.code = function(code, language) {
            const codeText = typeof code === 'object' ? code.text : code;
            const codeLang = typeof code === 'object' ? code.lang : language;
            if (codeLang === 'mermaid') {
                return '<div class="mermaid">' + codeText + '</div>';
            }
            return originalCodeRenderer(code, language);
        };

        marked.setOptions({ renderer: renderer, gfm: true, breaks: false });

        // Generate Table of Contents
        function generateTOC(container) {
            // Only select headings that are direct content, not from TOC itself
            const headings = container.querySelectorAll('h1, h2, h3, h4');
            if (headings.length === 0) return null;

            // Filter out any headings that might be inside .toc-container
            const contentHeadings = Array.from(headings).filter(h => !h.closest('.toc-container'));
            // Suppress TOC for documents with 3 or fewer headings
            if (contentHeadings.length <= 3) return null;

            const tocItems = [];
            contentHeadings.forEach((heading, index) => {
                const text = heading.textContent;
                const slug = text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-+|-+$/g, '');  // Remove leading/trailing dashes
                const id = (slug || 'heading') + '-' + index;
                heading.setAttribute('id', id);
                tocItems.push({ text, id, level: heading.tagName.toLowerCase() });
            });

            let tocHtml = '<ul>';
            tocItems.forEach(item => {
                const escapedText = item.text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                tocHtml += `<li><a href="#${item.id}" class="toc-${item.level}">${escapedText}</a></li>`;
            });
            tocHtml += '</ul>';

            const tocContainer = document.createElement('div');
            tocContainer.className = 'toc-container';
            tocContainer.innerHTML = `
                <div class="toc-header" onclick="this.parentElement.classList.toggle('collapsed')">
                    <span class="toc-title">Table of Contents</span>
                    <span class="toc-toggle">▼</span>
                </div>
                <div class="toc-content">${tocHtml}</div>
            `;

            // Add click handlers for smooth scrolling
            tocContainer.querySelectorAll('a[href^="#"]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        // Update URL hash without jumping
                        history.pushState(null, '', link.getAttribute('href'));
                    }
                });
            });

            return tocContainer;
        }

        // Update breadcrumb
        function updateBreadcrumb(docPath) {
            const breadcrumb = document.getElementById('breadcrumb');
            if (!docPath || docPath === 'index.md') {
                breadcrumb.innerHTML = '';
                return;
            }

            const parts = docPath.replace('.md', '').split('/');
            let html = '<a href="?doc=index.md">Docs</a>';

            parts.forEach((part, i) => {
                html += '<span>/</span>';
                const name = part.charAt(0).toUpperCase() + part.slice(1).replace(/-/g, ' ');
                if (i === parts.length - 1) {
                    html += name;
                } else {
                    html += `<a href="?doc=${parts.slice(0, i+1).join('/')}/index.md">${name}</a>`;
                }
            });
            breadcrumb.innerHTML = html;
        }

        // Update active sidebar link
        function updateActiveLink(docPath) {
            document.querySelectorAll('.docs-sidebar a').forEach(a => {
                a.classList.toggle('active', a.dataset.doc === docPath);
            });
        }

        // Load documentation
        async function loadDoc(docPath) {
            const container = document.getElementById('readme');
            container.className = 'content-loading';
            container.innerHTML = 'Loading documentation...';

            try {
                let url, data;

                if (docPath) {
                    url = '/api/docs/' + docPath;
                    const res = await fetch(url);
                    data = await res.json();
                    if (data.error) throw new Error(data.error);
                } else {
                    // Default: load index.md or fallback to README
                    const res = await fetch('/api/docs/index.md');
                    data = await res.json();
                    if (data.error) {
                        // Fallback to /readme endpoint
                        const readmeRes = await fetch('/readme');
                        data = await readmeRes.json();
                    }
                    docPath = 'index.md';
                }

                container.className = 'markdown-body';
                container.innerHTML = marked.parse(data.content);

                // Rewrite image URLs to use /docs-assets/ endpoint
                const currentDir = docPath.includes('/') ? docPath.substring(0, docPath.lastIndexOf('/')) : '';
                container.querySelectorAll('img').forEach(img => {
                    const src = img.getAttribute('src');
                    // Skip absolute URLs and already-rewritten paths
                    if (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('/')) return;
                    // Resolve relative path and rewrite to /docs-assets/
                    const fullPath = currentDir ? currentDir + '/' + src : src;
                    img.setAttribute('src', '/docs-assets/' + fullPath);
                });

                // Generate and insert TOC
                const toc = generateTOC(container);
                if (toc) container.insertBefore(toc, container.firstChild);

                // Render mermaid diagrams
                await mermaid.run({ nodes: document.querySelectorAll('.mermaid') });

                // Intercept clicks on .md links within content
                container.querySelectorAll('a[href$=".md"]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        const href = link.getAttribute('href');
                        // Skip external links
                        if (href.startsWith('http://') || href.startsWith('https://')) return;
                        e.preventDefault();
                        // Resolve relative path based on current doc
                        let targetDoc = href;
                        if (!href.startsWith('/') && docPath && docPath.includes('/')) {
                            // Relative link from subdirectory
                            const currentDir = docPath.substring(0, docPath.lastIndexOf('/'));
                            targetDoc = currentDir + '/' + href;
                        }
                        // Normalize path (handle ../)
                        const parts = targetDoc.split('/');
                        const normalized = [];
                        for (const part of parts) {
                            if (part === '..') normalized.pop();
                            else if (part !== '.') normalized.push(part);
                        }
                        loadDoc(normalized.join('/'));
                    });
                });

                // Update UI
                updateBreadcrumb(docPath);
                updateActiveLink(docPath);

                // Update URL without reload
                const newUrl = '?doc=' + docPath;
                if (window.location.search !== newUrl) {
                    history.pushState({doc: docPath}, '', newUrl);
                }

                // Close mobile sidebar
                document.getElementById('sidebar').classList.remove('open');

                // Scroll to top
                window.scrollTo(0, 0);

            } catch (e) {
                container.className = 'markdown-body';
                container.innerHTML = '<p style="color: #dc2626;">Error loading documentation: ' + e.message + '</p>';
            }
        }

        // Build navbar dynamically from API
        async function buildNavbar() {
            const sidebar = document.getElementById('sidebar');
            try {
                const res = await fetch('/api/docs/structure');
                const data = await res.json();

                let html = '';
                for (const section of data.sections) {
                    html += `<h3>${section.name}</h3><ul>`;
                    for (const doc of section.docs) {
                        // Add description as title attribute for hover tooltip
                        const titleAttr = doc.description
                            ? ` title="${doc.description.replace(/"/g, '&quot;')}"`
                            : '';
                        // Framework docs use framework/ prefix
                        const docPath = doc.framework ? 'framework/' + doc.path : doc.path;
                        html += `<li><a href="?doc=${docPath}" data-doc="${docPath}"${titleAttr}>${doc.title}</a></li>`;
                    }
                    html += '</ul>';
                }

                sidebar.innerHTML = html;

                // Attach click handlers to new links
                sidebar.querySelectorAll('a').forEach(a => {
                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        loadDoc(a.dataset.doc);
                    });
                });

                // Update active state for current doc
                const urlParams = new URLSearchParams(window.location.search);
                const currentDoc = urlParams.get('doc') || 'index.md';
                updateActiveLink(currentDoc);

            } catch (e) {
                sidebar.innerHTML = '<p style="color: #dc2626;">Error loading navigation</p>';
                console.error('Failed to load navbar:', e);
            }
        }

        // Handle browser back/forward
        window.addEventListener('popstate', (e) => {
            const doc = e.state?.doc || new URLSearchParams(window.location.search).get('doc');
            loadDoc(doc);
        });

        // Initial load
        async function init() {
            await buildNavbar();
            const urlParams = new URLSearchParams(window.location.search);
            const initialDoc = urlParams.get('doc');
            loadDoc(initialDoc);
        }
        init();
    </script>
</body>
</html>
